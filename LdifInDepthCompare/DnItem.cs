/**Author: Simonluca Scillitani
 * Company: Illogic 
 * http://www.illogic.software
 * summary: This class is a Dn Item and represent a LDAP record
 */

using System;
using System.Collections.Generic;


namespace LdifInDepthCompare
{
    public class DnItem 
    {
        private Crypto crpt;
        private String dn { get; set; }
        private String dnHash { get; set; }
        private String fullHash { get; set; }
        //NOTE the sorted list containts <hashKey, value>
        private SortedDictionary<String, SortedList<String,String>> internalMap;
        //this variable is used for the hash DO NOT TOUCH
        private String fullLine;


        public DnItem(){
            internalMap = new SortedDictionary<string, SortedList<String,String>>();
            fullLine = "";
            crpt = new Crypto();
        }

        /**Start the dn recording by initializing the dn and the hash variables
        */
        public void openRecording(String dn)
        {
            Logger.write(Constants.DEBUG_LEVELS.DEBUG, "Open recording for ->" + dn);
            this.dn = dn;
            this.dnHash = "NONE";
            this.fullHash = "NONE";
        }


        /**This methods invoke the hashing function for all the data as it is supposed that there are not further data to add.
        */
        public void closeRecording()
        {

            //calculate and assign dn hash
            this.dnHash = crpt.getHashString(this.dn);
            Logger.write(Constants.DEBUG_LEVELS.DEBUG, "Calculated dn hash ->" + this.dnHash);


            //calculate and assign the fullhash
            this.fullLine = ""; //be sure to reset
                                
            /* How the fullline will be built?
             * SortedDictionary.KEY[A]+SortedList.KEY[1]....SortedList.KEY[N]....SortedDictionary.KEY[N]
             * SortedDictionary.KEY are real LDAP keys
             * SortedList.KEY are keys generated by hashing the Value of the K,V touple
             */
            //first concatenate all the keys
            foreach (String key in this.internalMap.Keys){
                this.fullLine += key;
                //foreach k,v in the SortedList we get the K so the concatenation is:
                foreach (String slk in this.internalMap[key].Keys){
                    this.fullLine += slk;
                }
            }

            //so we hash the key0+hash[1..N]...keyN sequence to get a oneway deterministic hash
            this.fullHash = crpt.getHashString(this.fullLine);
            Logger.write(Constants.DEBUG_LEVELS.DEBUG, "Calculated fullHash -> " + this.fullHash);
            Logger.write(Constants.DEBUG_LEVELS.DEBUG, "Recording closed for -> " + this.dn);
        }


        public String getDN() { return this.dn; }

        public String getDnHash() { return this.dnHash; }

        public String getDnFullHash() { return this.fullHash;  }

        public String getConcatenatedFields(){
            String concat = "";
            foreach(String key in internalMap.Keys){
                SortedList<String,String> tempList = internalMap[key];
                foreach (String sTempVal in tempList.Values)
                {
                    concat += key+":"+sTempVal + Environment.NewLine;
                }
            }
            return concat;
        }

        public void addLine(String line){
            Logger.write(Constants.DEBUG_LEVELS.DEBUG, line);
            //split and put in the hash for fast search
            String[] keyValue = line.Split(':');
            String rebuild = "";
            for (int i = 1; i < keyValue.Length; i++) { rebuild += keyValue[i]; }
            if (!internalMap.ContainsKey(keyValue[0])) internalMap.Add(keyValue[0], new SortedList<String,String>());
            //we use as key for the SortedList the hash of the value
            internalMap[keyValue[0]].Add(crpt.getHashString(rebuild.Trim()),rebuild);

        }

        private SortedDictionary<String, SortedList<String,String>> getInternalMap() { return this.internalMap; }

        public String getFullLine() { return this.fullLine;  }


        /**compare a second item with the current and returns a new DnItem filled with the results*/
        public DnItem compare(DnItem anItem){
            //create the diff item
            DnItem compared = new DnItem();
            compared.dn = this.dn;
            //extract the map from the second itemp
            SortedDictionary<String, SortedList<String,String>> aDicAnItem = anItem.getInternalMap();

            //check forward
            //for each key we need to check if the values are equal in both items, if they are not then we write a special value
            foreach(String key in this.internalMap.Keys){
                if (aDicAnItem.ContainsKey(key)){
                    SortedList<String,String> lim = this.internalMap[key];
                    SortedList<String,String> ada = aDicAnItem[key];
                    foreach(KeyValuePair<String,String> la in lim){
                        bool found = false;
                        foreach(KeyValuePair<String, String> al in ada){
                            if (la.Key==al.Key) {
                                found = true;
                                compared.addLine(key + ":" + al.Value);
                                break;
                            }
                        }
                        if (!found) compared.addLine(key + ":" + "*MISSING/MISMATCH VALUE FORWARD* VALUE A=" + la.Value);
                    }
                } else {
                    //if the second item does not contain the key we add this
                    foreach(String str in this.internalMap[key].Values)
                        compared.addLine(key+": *MISSING KEY FORWARD* VALUE A="+str);
                } 
            }

            //check backward
            //for each key we need to check if the values are equal in both items, if they are not then we write a special value
            foreach (String key in aDicAnItem.Keys)
            {
                if (this.internalMap.ContainsKey(key))
                {
                    SortedList<String,String> lim = aDicAnItem[key];
                    SortedList<String,String> ada = this.internalMap[key];
                    foreach (KeyValuePair<String, String> la in lim)
                    {
                        bool found = false;
                        foreach (KeyValuePair<String, String> al in ada)
                        {
                            if (la.Key == al.Key)
                            {
                                found = true;
                                //we don't need to write again the match, we already did in the forward phase
                                break;
                            }
                        }
                        if (!found) compared.addLine(key + ":" + "*MISSING/MISMATCH VALUE BACKWARD* VALUE B=" + la.Value);
                    }
                }
                else
                {
                    //if the second item does not contain the key we add this
                    foreach (String str in aDicAnItem[key].Values)
                        compared.addLine(key + ": *MISSING KEY BACKWARD* VALUE B=" + str);
                }
            }

            return compared;
        }
    }
}
